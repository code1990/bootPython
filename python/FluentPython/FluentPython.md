## 第1章Python
1.1一摞
1.2如何使用特殊方法
1.2.1模拟数值类型
1.2.2字符串表示形式
1.2.3算术运算符
1.2.4自定义的布尔值
1.3特殊方法一览
1.4为什么
第二部分
## 第2章序列构成的数组
2.1内置序列类型概览
2.2列表推导和生成器表达式
2.2.1列表推导和可读性
2.2.2列表推导同
2.2.3笛卡儿积
2.2.4生成器表达式
2.3元组不仅仅是不可变的列表
2.3.1元组和记录
2.3.2元组拆包
2.3.3嵌套元组拆包
2.3.4具名元组
2.3.5作为不可变列表的元组
2.4切片
2.4.1为什么切片和区间会忽略最后一个元素
2.4.2对对象进行切片
2.4.3多维切片和省略
2.4.4给切片赋值
2.5对序列使用
2.6序列的增量赋值
2.7list.sort
2.8用
2.8.1用
2.8.2用
2.9当列表不是首选时
2.9.1数组
2.9.2内存视图
2.9.3NumPy
2.9.4双向队列和其他形式的队列
## 第3章字典和集合
3.1泛映射类型
3.2字典推导
3.3常见的映射方法
3.4映射的弹性键查询
3.4.1defaultdict
3.4.2特殊方法
3.5字典的变种
3.6子类化
3.7不可变映射类型
3.8集合论
3.8.1集合字面量
3.8.2集合推导
3.8.3集合的操作
3.9dict
3.9.1一个关于效率的实验
3.9.2字典中的散列表
3.9.3dict
3.9.4set
## 第4章文本和字节序列
4.1字符问题
4.2字节概要
4.3基本的编解码器
4.4了解编解码问题
4.4.1处理
4.4.2处理
4.4.3使用预期之外的编码加载模块时抛出的
4.4.4如何找出字节序列的编码
4.4.5BOM：有用的鬼符
4.5处理文本文件
4.6为了正确比较而规范化
4.6.1大小写折叠
4.6.2规范化文本匹配实用函数
4.6.3极端“规范化”：去掉变音符号
4.7Unicode
4.8Unicode
4.9支持字符串和字节序列的双模式
4.9.1正则表达式中的字符串和字节序列
4.9.2os
第三部分
## 第5章一等函数
5.1把函数视作对象
5.2高阶函数
5.3匿名函数
5.4可调用对象
5.5用户定义的可调用类型
5.6函数内省
5.7从定位参数到仅限关键字参数
5.8获取关于参数的信息
5.9函数注解
5.10支持函数式编程的包
5.10.1operator
5.10.2使用
## 第6章使用一等函数实现设计模式
6.1案例分析：重构“策略”模式
6.1.1经典的“策略”模式
6.1.2使用函数实现“策略”模式
6.1.3选择最佳策略：简单的方式
6.1.4找出模块中的全部策略
6.2“命令”模式
## 第7章函数装饰器和闭包
7.1装饰器基础知识
7.2Python
7.3使用装饰器改进“策略”模式
7.4变量作用域规则
7.5闭包
7.6nonlocal
7.7实现一个简单的装饰器
7.8标准库中的装饰器
7.8.1使用
7.8.2单分派泛函数
7.9叠放装饰器
7.10参数化装饰器
7.10.1一个参数化的注册装饰器
7.10.2参数化
第四部分
## 第8章对象引用、可变性和垃圾回收
8.1变量不是盒子
8.2标识、相等性和别名
8.2.1在
8.2.2元组的相对不可变性
8.3默认做浅复制
8.4函数的参数作为引用时
8.4.1不要使用可变类型作为参数的默认值
8.4.2防御可变参数
8.5del
8.6弱引用
8.6.1WeakValueDictionary
8.6.2弱引用的局限
8.7Python
## 第9章符合
9.1对象表示形式
9.2再谈向量类
9.3备选构造方法
9.4classmethod
9.5格式化显示
9.6可散列的
9.7Python
9.8使用
9.9覆盖类属性
## 第10章序列的修改、散列和切片
10.1Vector
10.2Vector
10.3协议和鸭子类型
10.4Vector
10.4.1切片原理
10.4.2能处理切片的
10.5Vector
10.6Vector
10.7Vector
## 第11章接口：从协议到抽象基类
11.1Python
11.2Python
11.3使用猴子补丁在运行时实现协议
11.4Alex
11.5定义抽象基类的子类
11.6标准库中的抽象基类
11.6.1collections.abc
11.6.2抽象基类的数字塔
11.7定义并使用一个抽象基类
11.7.1抽象基类句法详解
11.7.2定义
11.7.3Tombola
11.8Tombola
11.9Python
11.10鹅的行为有可能像鸭子
## 第12章继承的优缺点
12.1子类化内置类型很麻烦
12.2多重继承和方法解析顺序
12.3多重继承的真实应用
12.4处理多重继承
12.5一个现代示例：Django
## 第13章正确重载运算符
13.1运算符重载基础
13.2一元运算符
13.3重载向量加法运算符
13.4重载标量乘法运算符
13.5众多比较运算符
13.6增量赋值运算符
第五部分
## 第14章可迭代的对象、迭代器和生成器
14.1Sentence
14.2可迭代的对象与迭代器的对比
14.3Sentence
14.4Sentence
14.5Sentence
14.6Sentence
14.7何时使用生成器表达式
14.8另一个示例：等差数列生成器
14.9标准库中的生成器函数
14.10Python
14.11可迭代的归约函数
14.12深入分析
14.13案例分析：在数据库转换工具中使用生成器
14.14把生成器当成协程
## 第15章上下文管理器和
15.1先做这个，再做那个：
15.2上下文管理器和
15.3contextlib
15.4使用
## 第16章协程
16.1生成器如何进化成协程
16.2用作协程的生成器的基本行为
16.3示例：使用协程计算移动平均值
16.4预激协程的装饰器
16.5终止协程和异常处理
16.6让协程返回值
16.7使用
16.8yield
16.9使用案例：使用协程做离散事件仿真
16.9.1离散事件仿真简介
16.9.2出租车队运营仿真
## 第17章使用期物处理并发
17.1示例：网络下载的三种风格
17.1.1依序下载的脚本
17.1.2使用
17.1.3期物在哪里
17.2阻塞型
17.3使用
17.4实验
17.5显示下载进度并处理错误
17.5.1flags2
17.5.2使用
17.5.3线程和多进程的替代方案
## 第18章使用
18.1线程与协程对比
18.1.1asyncio.Future
18.1.2从期物、任务和协程中产出
18.2使用
18.3避免阻塞型调用
18.4改进
18.4.1使用
18.4.2使用
18.5从回调到期物和协程
18.6使用
18.6.1使用
18.6.2使用
18.6.3更好地支持并发的智能客户端
第六部分
## 第19章动态属性和特性
19.1使用动态属性转换数据
19.1.1使用动态属性访问
19.1.2处理无效属性名
19.1.3使用
19.1.4使用
19.1.5使用特性获取链接的记录
19.2使用特性验证属性
19.2.1LineItem
19.2.2LineItem
19.3特性全解析
19.3.1特性会覆盖实例属性
19.3.2特性的文档
19.4定义一个特性工厂函数
19.5处理属性删除操作
19.6处理属性的重要属性和函数
19.6.1影响属性处理方式的特殊属性
19.6.2处理属性的内置函数
19.6.3处理属性的特殊方法
## 第20章属性描述符
20.1描述符示例：验证属性
20.1.1LineItem
20.1.2LineItem
20.1.3LineItem
20.2覆盖型与非覆盖型描述符对比
20.2.1覆盖型描述符
20.2.2没有
20.2.3非覆盖型描述符
20.2.4在类中覆盖描述符
20.3方法是描述符
20.4描述符用法建议
20.5描述符的文档字符串和覆盖删除操作
## 第21章类元编程
21.1类工厂函数
21.2定制描述符的类装饰器
21.3导入时和运行时比较
21.4元类基础知识
21.5定制描述符的元类
21.6元类的特殊方法
21.7类作为对象
